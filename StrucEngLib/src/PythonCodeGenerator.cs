using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Rhino.DocObjects;
using StrucEngLib.Model;
using StrucEngLib.Utils;
using Layer = StrucEngLib.Model.Layer;


namespace StrucEngLib
{
    /// <summary>
    /// Code generator to generate python code based on UI input.
    /// </summary>
    public class PythonCodeGenerator
    {
        private string header = $@"
from compas_fea.cad import rhino
from compas_fea.structure import ElasticIsotropic
from compas_fea.structure import ElementProperties as Properties
from compas_fea.structure import GeneralDisplacement
from compas_fea.structure import GeneralStep
from compas_fea.structure import GravityLoad
from compas_fea.structure import AreaLoad
from compas_fea.structure import PointLoad
from compas_fea.structure import PinnedDisplacement
from compas_fea.structure import RollerDisplacementX
from compas_fea.structure import RollerDisplacementY
from compas_fea.structure import RollerDisplacementXY
from compas_fea.structure import ShellSection
from compas_fea.structure import Structure

import sandwichmodel_main as SMM

# Snippets based on code of Andrew Liew (github.com/andrewliew), Benjamin Berger (github.com/Beberger)
# Code Generated by StrucEngLib Plugin {StrucEngLibPlugin.Version}, {StrucEngLibPlugin.Website}

name = 'Rahmen'
path = 'C:/Temp/'
mdl = Structure(name=name, path=path)
";

        private const string footer = @"
# Summary

mdl.summary()

# Run

mdl.analyse_and_extract(software='abaqus', fields=['u','sf','sm'])

# rhino.plot_data(mdl, step='step_load', field='sm1',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='sm2',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='sm3',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='sf4',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='sf5',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='sf1',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='sf2',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='sf3',cbar_size=1)
# rhino.plot_data(mdl, step='step_load', field='um',cbar_size=1)
# #print(mdl.elements[251])
# #print(mdl.elements[100])
# #print(mdl.elements[222])
";

        private readonly Workbench _model;

        public PythonCodeGenerator(Workbench model)
        {
            _model = model;
        }

        private int _loadIdCounter = 0;
        private string RemoveSpaces(string id) => id.Replace(" ", "_");
        private string LoadId() => "load_" + _loadIdCounter++;
        private string LayerId(string id) => RemoveSpaces(id) + "_element";
        private string SetId(string id) => RemoveSpaces(id) + "_set";
        private string SectionId(string id) => RemoveSpaces(id) + "_sec";
        private string PropId(string id) => RemoveSpaces(id) + "_prop";
        private string MatElasticId(string id) => RemoveSpaces(id) + "_mat_elastic";
        private string DispId(string id) => RemoveSpaces(id) + "_disp";

        private string EmitIfNotEmpty(string key, string value, string comma = ",")
            => string.IsNullOrWhiteSpace(value) ? "" : $" {key}={value}{comma}";

        private string _nl = Environment.NewLine;

        public string Generate()
        {
            _loadIdCounter = 0;
            var b = new StringBuilder();
            b.Append(header);

            foreach (var layer in _model.Layers ?? Enumerable.Empty<Layer>())
            {
                EmitLayer(layer, b);
            }

            var loadNameMap = new Dictionary<Load, string>();
            foreach (var load in _model.Loads ?? Enumerable.Empty<Load>())
            {
                EmitLoad(load, b, loadNameMap);
            }

            EmitSteps(b, loadNameMap);
            b.Append(footer);
            return b.ToString();
        }

        private void EmitLayer(Layer layer, StringBuilder b)
        {
            if (layer.LayerType == LayerType.ELEMENT)
            {
                var element = (Element) layer;
                var layerId = LayerId(element.GetName());
                var layerName = element.GetName();
                b.Append(_nl + $@"# == Element {layerName}" + _nl);
                b.Append(
                    $@"rhino.add_nodes_elements_from_layers(mdl, mesh_type='ShellElement', layers=['{layerName}'])" +
                    _nl);

                var mat = element.ElementMaterialElastic;
                var matId = MatElasticId(layerId);
                b.Append($@"mdl.add(ElasticIsotropic(name='{matId}', E={mat.E}, v={mat.V}, p={mat.P}))" + _nl);
                var sectionId = SectionId(layerId);
                b.Append(
                    $@"mdl.add(ShellSection(name='{sectionId}', t={element.ElementShellSection.Thickness})) #[mm] " +
                    _nl);
                var propId = PropId(layerId);
                b.Append(
                    $@"mdl.add(Properties(name='{propId}', material='{matId}', section='{sectionId}', elset='{layerName}'))" +
                    _nl);

                if (element.LoadConstraint != null)
                {
                    var c = element.LoadConstraint;
                    b.Append(
                        $@"mdl.elements[{c.ElementNumber}].axes.update({{'ex': [{c.Ex0}, {c.Ex1}, {c.Ex2}], 'ey': [{c.Ey0}, {c.Ey1}, {c.Ey2}], 'ez': [{c.Ez0}, {c.Ez1}, {c.Ez2}]}}) " +
                        _nl);
                }
            }

            if (layer.LayerType == LayerType.SET)
            {
                var set = (Set) layer;
                var setName = set.GetName();
                var setId = SetId(setName);
                b.Append(_nl + $@"# == Set {set.GetName()}" + _nl);
                b.Append($@"rhino.add_sets_from_layers(mdl, layers=['{setName}'] ) " + _nl);
                var dispId = DispId(setId);

                if (set.SetGeneralDisplacement != null)
                {
                    var general = set.SetGeneralDisplacement;
                    var args = new StringBuilder();
                    args.Append(EmitIfNotEmpty("x", set.SetGeneralDisplacement.Ux))
                        .Append(EmitIfNotEmpty("y", set.SetGeneralDisplacement.Uy))
                        .Append(EmitIfNotEmpty("z", set.SetGeneralDisplacement.Uz))
                        .Append(EmitIfNotEmpty("xx", set.SetGeneralDisplacement.Rotx))
                        .Append(EmitIfNotEmpty("yy", set.SetGeneralDisplacement.Roty))
                        .Append(EmitIfNotEmpty("zz", set.SetGeneralDisplacement.Rotz));
                    b.Append($@"mdl.add([GeneralDisplacement(name='{dispId}', {args} nodes='{setName}')]) " + _nl);
                }
            }
        }

        private void EmitLoad(Load load, StringBuilder b, Dictionary<Load, string> loadNameMap)
        {
            var loadId = "";
            switch (load.LoadType)
            {
                case LoadType.Area:
                {
                    var area = (LoadArea) load;
                    var layersList = StringUtils.ListToPyStr(load.Layers, layer => layer.GetName());
                    b.Append(_nl + $@"# == Load Area {layersList}" + _nl);
                    loadId = LoadId() + "_area";
                    var z = EmitIfNotEmpty("z", area.Z);
                    var x = EmitIfNotEmpty("x", area.X);
                    var y = EmitIfNotEmpty("y", area.Y);
                    b.Append(
                        $@"mdl.add(AreaLoad(name='{loadId}', elements={layersList}, {z} {x} {y} axes='{area.Axes}')) " +
                        _nl);
                    break;
                }
                case LoadType.Gravity:
                {
                    var g = (LoadGravity) load;
                    string layersList = StringUtils.ListToPyStr(load.Layers, layer => layer.GetName());
                    b.Append(_nl + $@"#== Load Gravity {layersList}" + _nl);
                    loadId = LoadId() + "_gravity";
                    b.Append(
                        $@"mdl.add(GravityLoad(name='{loadId}', x={g.X}, y={g.Y}, z={g.Z}, elements={layersList}))" +
                        _nl);
                    break;
                }
                case LoadType.Point:
                {
                    var p = (LoadPoint) load;
                    string layersList = StringUtils.ListToPyStr(load.Layers, layer => layer.GetName());
                    b.Append(_nl + $@"#== Load Point {layersList}" + _nl);
                    loadId = LoadId() + "_point";
                    var z = EmitIfNotEmpty("z", p.Z);
                    var x = EmitIfNotEmpty("x", p.X);
                    var y = EmitIfNotEmpty("y", p.Y);
                    var zz = EmitIfNotEmpty("zz", p.ZZ);
                    var xx = EmitIfNotEmpty("xx", p.XX);
                    var yy = EmitIfNotEmpty("yy", p.YY);
                    b.Append(
                        $@"mdl.add(PointLoad(name='{loadId}', {x} {y} {z} {xx} {yy} {zz} elements={layersList}))" +
                        _nl);
                    break;
                }
                default:
                    // XXX: Ignore rest
                    break;
            }

            loadNameMap.Add(load, loadId);
        }

        private void EmitSteps(StringBuilder b, Dictionary<Load, string> loadNameMap)
        {
            b.Append(_nl + $@"# == Steps" + _nl);
            var stepCounter = 0;
            /*
             * stepPair: <float order as key, List<Steps> which belong to same order
             * Order is already by key (asc)
             */
            var stepOrderList = new Dictionary<string, List<Model.Step>>();
            foreach (var stepPair in GroupSteps(_model))
            {
                var stepName = "step_" + stepCounter++;
                stepOrderList.Add(stepName, stepPair.Value);
                var loadsNames = new List<string>();
                var dispNames = new List<string>();
                foreach (var stepEntry in stepPair.Value)
                {
                    switch (stepEntry.StepType)
                    {
                        case StepType.Load:
                            loadsNames.Add(loadNameMap[stepEntry.Load]);
                            break;
                        case StepType.Set:
                            dispNames.Add(stepEntry.Set.Name);
                            break;
                        default:
                            // XXX: Ignore rest
                            break;
                    }
                }

                var loadStr = "";
                var dispStr = "";
                if (loadsNames.Count > 0)
                {
                    loadStr = $" loads={StringUtils.ListToPyStr(loadsNames, name => name)}, ";
                }

                if (dispNames.Count > 0)
                {
                    dispStr = $" displacements={StringUtils.ListToPyStr(dispNames, name => name)}, ";
                }

                b.Append($@"mdl.add(GeneralStep(name='{stepName}', {loadStr} {dispStr} nlgeom=False))" + _nl);
            }

            b.Append($@"mdl.steps_order = {StringUtils.ListToPyStr(stepOrderList.Keys.ToList(), s => s)} " + _nl);
        }


        /*
         * Given A workbench, group steps according to their order (float).
         * Result is a List of steps belonging to the same order-id, ordered by order-id
         */
        private SortedDictionary<float, List<Model.Step>> GroupSteps(Workbench model)
        {
            var steps = new SortedDictionary<float, List<Model.Step>>();
            foreach (var step in model.Steps)
            {
                try
                {
                    var order = float.Parse(step.Order);
                    if (String.IsNullOrEmpty(step.Order)) continue;
                    if (steps.ContainsKey(order))
                    {
                        steps[order].Add(step);
                    }
                    else
                    {
                        steps.Add(order, new List<Model.Step>() {step});
                    }
                }
                catch (Exception)
                {
                    // XXX: We ignore invalid step numbers
                }
            }

            return steps;
        }
    }
}